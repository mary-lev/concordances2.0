{{import json}}
{{response.files.append(URL(r=request,c='static',f='/js/d3.js'))}}

{{response.files.append(URL('static', 'js/d3.v3.min.js'))}}
{{response.files.append(URL('static', 'js/d3.layout.js'))}}
{{response.files.append(URL('static', 'js/mapper.js'))}}
{{response.files.append(URL('static', 'js/underscore.js'))}}
{{extend 'layout.html'}}
<h1>
    Корелляции
</h1>
<p>
    Ищем пересечения лексики в каждом тексте одного автора.
</p>
<div id="chart"></div>
{{=lists}}
{{for all in newnew:}}
{{=all}}<br>
{{pass}}
<script>

    var labels=["день", "ночь", "утро", "вечер", "сумерки", "рассвет", "заря", "дневной", "утренний", "вечерний", "ночной", "дневной", "земля", "небо", "лес"];
var chord = d3.layout.chord()
  .padding(.07)
  .sortSubgroups(d3.descending)
.matrix({{=newnew}});

		var w = 1100, h = 1100, r0 = Math.min(w, h) * .30, r1 = r0 * 1.1;

		//		var fill = d3.scale.ordinal().domain(d3.range(4)).range(
		//				[ "black", "#FFDD89", "#957244", "#F26223", "blue", "green",
		//						"purple", "red", "orange", "cyan", "grey", "lightblue",
		//						"lightgrey", "lightpurple", "lightred", "pink",
		//						"yellow", "violet", "brown" ]);

var colors=["#008000","#FFFF00","#ADD8E6","#FF0000","#C0C0C0","#FFFF00","#000000","#A52A2A","#0000FF","#FF00FF","#800080","#800080","#808080","#00FFFF","#FF00FF","#88abff","#88abff","#3366FF","#88abff","#0033FF","#141005","#141005","#141005","#141005","#88abff","#141005","#3366FF","#3db8e4","#0033FF","#0033FF","#88abff","#0033FF","#3366FF"]

		var fill = d3.scale.ordinal().domain(d3.range(colors.length)).range(
				colors);

		var svg = d3.select("#chart").append("svg").attr("width", w).attr(
				"height", h).append("g").attr("transform",
				"translate(" + w / 2 + "," + h / 2 + ")");

		svg.append("g").selectAll("path").data(chord.groups).enter().append(
				"path").style("fill", function(d) {
			return fill(d.index);
		}).style("stroke", function(d) {
			return fill(d.index);
		}).attr("d", d3.svg.arc().innerRadius(r0).outerRadius(r1)).on(
				"mouseover", fade(.01)).on("mouseout", fade(1));

		var ticks = svg.append("g").selectAll("g").data(chord.groups).enter()
				.append("g").selectAll("g").data(groupTicks).enter()
				.append("g").attr(
						"transform",
						function(d) {
							return "rotate(" + (d.angle * 180 / Math.PI - 90)
									+ ")" + "translate(" + r1 + ",0)";
						});

		ticks.append("line").attr("x1", 1).attr("y1", 0).attr("x2", 5).attr(
				"y2", 0).style("stroke", "#000");

		ticks.append("text").style("font-size", "14px").attr("x", 10).attr("dy", ".35em").attr(
				"text-anchor", function(d) {
					return d.angle > Math.PI ? "end" : null;
				}).attr("transform", function(d) {
			return d.angle > Math.PI ? "rotate(180)translate(-16)" : null;
		}).text(function(d) {
			return d.label;
		});

		// This fills in the lines.
		svg.append("g").attr("class", "chord").selectAll("path").data(
				chord.chords).enter().append("path").style("fill", function(d) {
			return fill(d.target.index);
		}).attr("d", d3.svg.chord().radius(r0)).style("opacity", 1);

		/** Returns an array of tick angles and labels, given a group. */
		function groupTicks(d) {
			var k = (d.endAngle - d.startAngle) / d.value;
			return d3.range(d.value / 2, d.value, d.value / 2).map(
					function(v, i) {
						return {
							angle : v * k + d.startAngle,
							label : labels[d.index]
						//label: d.groups
						};
					});
		}

		/** Returns an event handler for fading a given chord group. */
		function fade(opacity) {
			return function(g, i) {
				svg.selectAll("g.chord path").filter(function(d) {
					return d.source.index != i && d.target.index != i;
				}).transition().style("opacity", opacity);
			};
		}
		

</script>
